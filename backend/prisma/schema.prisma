generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Informations de base
  email     String? @unique
  username  String? @unique
  
  // Wallet connection
  walletAddress String  @unique @map("wallet_address")
  chainId       Int?    @default(1) @map("chain_id")
  
  // Statut de connexion
  isConnected   Boolean @default(true) @map("is_connected")
  lastLoginAt   DateTime @default(now()) @map("last_login_at")
  
  // Activité PUBLIQUE (tout le monde peut voir)
  activityScore   Int     @default(0) @map("activity_score") // Points d'activité totaux
  lastActivityAt  DateTime @default(now()) @map("last_activity_at") // Dernière activité
  level           Int     @default(1)
  experience      Int     @default(0)
  tokenBalance    Decimal @default(0) @db.Decimal(18, 8) @map("token_balance")
  bridgeCount     Int     @default(0) @map("bridge_count") // Nombre de bridges réussies
  
  // Métadonnées
  nonce         String?
  profileImage  String? @map("profile_image")
  bio           String?
  
  // Relations
  transactions Transaction[]
  islands      Island[]
  
  @@index([walletAddress])
  @@index([activityScore]) // Pour le classement public
  @@index([lastActivityAt]) // Pour voir qui est actif récemment
  @@map("users")
}


model Transaction {
  id        Int    @id @default(autoincrement())
  userId    String
  type      String
  chain     String
  amount    Float
  reward    String
  timestamp DateTime @default(now())
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Island {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Propriétaire de l'île
  userId       String   @map("user_id")
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Métadonnées de l'île
  name         String
  seed         BigInt   // Seed de génération procédurale
  isActive     Boolean  @default(true) @map("is_active") // Île actuellement utilisée

  // Données de génération (JSON)
  islandData   Json     @map("island_data") // IslandGenerationResult
  
  // État de l'île et statistiques du biome
  treeCount    Int      @default(0) @map("tree_count")
  totalTrees   Int      @default(0) @map("total_trees") // Nombre total d'arbres plantés
  healthScore  Decimal  @default(100) @db.Decimal(5, 2) @map("health_score") // Santé globale du biome
  description  String?  @default("Mon île personnelle") // Description du biome
  
  lastModified DateTime @default(now()) @map("last_modified")
  lastUpdateAt DateTime @default(now()) @map("last_update_at") // Dernière mise à jour des stats
  version      String   @default("1.0.0")

  // Relations
  userTrees    IslandTree[]
  chests       IslandChest[]
  usedTiles    IslandUsedTile[]

  @@index([userId])
  @@index([isActive])
  @@index([seed])
  @@index([healthScore]) // Pour comparer les biomes
  @@index([totalTrees]) // Pour le classement
  @@map("islands")
}

model IslandTree {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")

  // Appartenance
  islandId  String   @map("island_id")
  island    Island   @relation(fields: [islandId], references: [id], onDelete: Cascade)

  // Données de l'arbre (JSON)
  treeData  Json     @map("tree_data") // TreeData interface

  @@index([islandId])
  @@map("island_trees")
}

model IslandChest {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")

  // Appartenance
  islandId  String   @map("island_id")
  island    Island   @relation(fields: [islandId], references: [id], onDelete: Cascade)

  // Données du coffre (JSON)
  chestData Json     @map("chest_data") // ChestData interface

  @@index([islandId])
  @@map("island_chests")
}

model IslandUsedTile {
  id        String   @id @default(cuid())

  // Appartenance
  islandId  String   @map("island_id")
  island    Island   @relation(fields: [islandId], references: [id], onDelete: Cascade)

  // Identifiant de la tuile utilisée
  tileKey   String   @map("tile_key")

  @@unique([islandId, tileKey])
  @@index([islandId])
  @@map("island_used_tiles")
}
